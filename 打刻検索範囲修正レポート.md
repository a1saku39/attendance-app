# 打刻データ検索範囲の修正レポート

## 問題の概要

### 発生していた問題
- **症状**: 出勤と退勤の打刻が同じ日であっても、時間が大きく離れていると、退勤時に既存の出勤行が見つからず、新しい行に追加されてしまう
- **具体例**: 
  - 社員コード1366の出勤打刻が90行目に記録
  - 退勤打刻時に「既存行が見つかりませんでした」となり、96行目に別の行として追加
  - デバッグログ17462行目で出勤（in）、19282行目で退勤時に新規行追加のログ

### 根本原因
`Code.gs`の`updateOrAppendRow`関数において、既存行を検索する範囲が**直近500行**に制限されていたため、以下の問題が発生していました：

1. **検索範囲の制限**: `Math.max(2, lastRow - 500)` により、直近500行のみを検索対象としていた
2. **時間経過による問題**: 出勤と退勤の間に他の社員の打刻が多数入ると、出勤行が検索範囲外になってしまう
3. **データ量増加による悪化**: データが蓄積されるほど、この問題が発生しやすくなる

## 実施した修正

### 修正箇所
`Code.gs` の `updateOrAppendRow` 関数（356〜427行目）

### 変更内容

#### 修正前
```javascript
// データがある場合、既存の行を検索(直近100行程度を検索対象とする)
if (lastRow > 1) {
  var startRow = Math.max(2, lastRow - 500);  // ← 直近500行のみ
  var numRows = lastRow - startRow + 1;
  var values = sheet.getRange(startRow, 1, numRows, 2).getValues();
  
  debugSheet.appendRow([new Date(), '検索範囲: ' + startRow + '行目から' + lastRow + '行目まで(' + numRows + '行)']);
  
  // 各行をチェックする際に詳細なデバッグログを出力（冗長）
  for (var i = values.length - 1; i >= 0; i--) {
    debugSheet.appendRow([new Date(), '行' + (startRow + i) + 'をチェック...']);
    // ... 詳細なログが各行ごとに出力される
  }
}
```

#### 修正後
```javascript
// データがある場合、既存の行を検索（全データを対象に検索）
if (lastRow > 1) {
  // 同じ日付・同じ社員コードの行を確実に見つけるため、全データを検索対象とする
  var startRow = 2;  // ← 全データを対象に変更
  var numRows = lastRow - 1;
  var values = sheet.getRange(startRow, 1, numRows, 2).getValues();
  
  debugSheet.appendRow([new Date(), '検索範囲: ' + startRow + '行目から' + lastRow + '行目まで(全' + numRows + '行を検索)']);
  
  // 検索条件を事前にフォーマット（効率化）
  var formattedSearchDate = String(data.date).trim();
  var formattedSearchId = String(data.id).trim();
  
  debugSheet.appendRow([new Date(), '検索条件: 日付="' + formattedSearchDate + '", 社員コード="' + formattedSearchId + '"']);
  
  // ループ内の冗長なログを削減し、見つかった時のみ詳細ログを出力
  for (var i = values.length - 1; i >= 0; i--) {
    // ... フォーマット処理（ログは削減）
    
    if (dateMatch && idMatch) {
      foundRow = startRow + i;
      debugSheet.appendRow([new Date(), '✓ 既存行を発見: ' + foundRow + '行目 (シート日付="' + formattedSheetDate + '", シートID="' + formattedSheetId + '")']);
      break;
    }
  }
  
  if (foundRow === -1) {
    debugSheet.appendRow([new Date(), '✗ 既存行が見つかりませんでした。全' + numRows + '行を検索しましたが、該当する日付・社員コードの組み合わせは存在しませんでした。新規行を追加します。']);
  }
}
```

### 主な改善点

1. **検索範囲の拡大**
   - 直近500行 → 全データを検索対象に変更
   - 同じ日付・同じ社員コードの行を確実に見つけられるようになった

2. **デバッグログの最適化**
   - 各行ごとの詳細ログを削減し、重要な情報のみを記録
   - 検索条件を明確に表示
   - 見つかった場合と見つからなかった場合のログを改善

3. **パフォーマンスの考慮**
   - 検索条件を事前にフォーマット（ループの外で一度だけ実行）
   - 下から上への検索により、最新データを優先的に検索

## 期待される効果

### 解決される問題
✅ 出勤と退勤が同じ日であれば、時間が何時間離れていても同じ行に記録される
✅ データ量が増えても、正確に既存行を見つけられる
✅ デバッグログが読みやすくなり、問題発生時の原因特定が容易になる

### 具体的なケース
- **修正前**: 出勤8:00、退勤20:00（12時間後）→ 別々の行に記録されることがある
- **修正後**: 出勤8:00、退勤20:00（12時間後）→ 必ず同じ行に記録される

## 注意事項

### パフォーマンスについて
- データ量が非常に多い場合（数万行以上）、検索に時間がかかる可能性があります
- 現状のデータ量（数千行程度）であれば、問題なく動作します
- 今後データ量が大幅に増加した場合は、以下の対策を検討してください：
  1. 月別にシートを分割する
  2. 検索範囲を「直近1ヶ月分」などに制限する（ただし日付ベースで）
  3. インデックス列を追加してより高速な検索を実現する

### Google Apps Scriptの制限
- Google Apps Scriptには実行時間の制限（6分）があります
- 大量のデータを扱う場合、この制限に注意が必要です
- 現在の実装では、通常の打刻操作であれば問題ありません

## デバッグログの確認方法

修正後、デバッグログには以下のような情報が記録されます：

```
検索開始: 日付=2025/12/17, 社員コード=1366, アクション=out
検索範囲: 2行目から543行目まで(全542行を検索)
検索条件: 日付="2025/12/17", 社員コード="1366"
✓ 既存行を発見: 90行目 (シート日付="2025/12/17", シートID="1366")
既存行(90行目)を更新します
退勤時刻を記録: 20:00
```

このログにより、どの範囲を検索し、どの行が見つかったかを明確に確認できます。

## テスト推奨事項

修正後、以下のケースでテストすることをお勧めします：

1. ✅ **通常の打刻**: 出勤と退勤が数時間以内
2. ✅ **長時間勤務**: 出勤と退勤が12時間以上離れている
3. ✅ **夜勤**: 日付をまたぐ勤務（出勤23:00、退勤翌日8:00）
4. ✅ **複数社員**: 同じ日に複数の社員が打刻した場合

## まとめ

この修正により、出勤と退勤が必ず同じ行に記録されるようになり、勤務時間の計算も正確に行われるようになります。デバッグログも改善され、問題が発生した場合の原因特定が容易になりました。

---
**修正日**: 2025-12-17  
**修正者**: AI Assistant  
**影響範囲**: `Code.gs` の `updateOrAppendRow` 関数  
**テスト状態**: 要テスト
